## 事务

### 概念

+ 事务
  + 满足 **ACID** 特性的一组操作，可以通过 **Commit** 提交一个事务，也可以使用 **Rollback** 进行回滚。
+ ACID
  + **原子性**
    + 事务被视为**不可分割的最小单元**，事务的所有操作**要么全部提交成功，要么全部失败回滚**。
  + **一致性**
    + 数据库在事务**执行前后**都保持**一致性状态**。在一致性状态下，**所有事务**对**同一个数据的读取结果都是相同的**。
  + **隔离性**
    + 一个事务所做的修改在**最终提交以前**，对其它事务是**不可见**的。
  + **持久性**
    + **一旦事务提交**，则其所做的修改将会**永远保存到数据库中**。
  + <img src="C:\Users\包志龙\Desktop\常用\file\mark down笔记\图片\Snipaste_2020-03-31_14-02-32.png" style="zoom:80%;" />

+ **MySQL** 默认采用**自动提交模式**。也就是说，如果不**显式**使用`START TRANSACTION`语句来开始一个事务，那么每个查询操作都会被当做一个事务并自动提交。

## 并发一致性问题

> 在并发环境下，事务的**隔离性**很难保证，因此会出现很多并发一致性问题。

### 丢失修改

+ T1 和 T2 两个事务都对一个**数据进行修改**，T1 先修改，T2 随后修改，**T2 的修改覆盖了 T1 的修改**。

### 读脏数据

+ T1 修改一个数据，T2 随后读取这个数据。如果 T1 撤销了这次修改，那么 T2 读取的数据是**脏数据**。

### 不可重复读

+ T2 **读取**一个数据，T1 对该数据做了**修改**。如果 T2 **再次读取**这个数据，此时读取的结果和第一次读取的结果不同。

  

> 产生**并发不一致性问题**的主要原因是**破坏了事务的隔离性**，**解决方法**是通过**并发控制来保证隔离性**。并发控制可以通过**封锁**来实现，但是封锁操作需要用户自己控制，相当复杂。数据库管理系统提供了**事务的隔离级别**，让用户以一种更轻松的方式处理并发一致性问题。

## 封锁

### 封锁粒度

**MySQL** 中提供了两种封锁粒度：**行级锁**以及**表级锁**。

应该**尽量只锁定需要修改的那部分数据**，**而不是所有的资源**。锁定的数据量越少，发生锁争用的可能就越小，系统的并发程度就越高。

但是加锁需要消耗资源，锁的各种操作（包括获取锁、释放锁、以及检查锁状态）都会增加系统开销。因此**封锁粒度越小，系统开销就越大**。

在选择封锁粒度时，需要在**锁开销**和**并发程度**之间做一个权衡。

### 封锁类型

+ **读写锁**
  + 互斥锁：简写为X锁，又称写锁
  + 共享锁：简写为S锁，又称读锁
  + 有以下两个规定：
    - 一个事务对数据对象 A 加了 **X 锁**，就可以对 A 进行**读取和更新**。**加锁期间其它事务不能对 A 加任何锁**。
    - 一个事务对数据对象 A 加了 **S 锁**，可以对 A 进行**读取操作**，但是不能进行更新操作。**加锁期间其它事务能对 A 加 S 锁，但是不能加 X 锁。**
+ **意向锁**
  + 使用意向锁（Intention Locks）可以**更容易地支持多粒度封锁**。

## 隔离级别

## 多版本并发控制

## Next-Key Locks

## 关系数据库设计理论

## ER图

Entity-Relationship,有三个组成部分：**实体**、**属性**、**联系**。

用来进行关系型数据库系统的概念设计。

### 实体的三种关系

一对一、一对多、多对多

+ 如果 A 到 B 是**一对多**关系，那么画个带箭头的线段**指向 B**；
+ 如果是**一对一**，画**两个带箭头**的线段；
+ 如果是**多对多**，画**两个不带箭头**的线段。