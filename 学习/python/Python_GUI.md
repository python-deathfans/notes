## 布局管理-pack

### 一、原理分析

+ side=top 空间布局
  + ![](https://pic.downk.cc/item/5ec8dc22c2a9a83be5b995d2.png)
+ side=left 空间布局
  + ![](https://pic.downk.cc/item/5ec8dbe8c2a9a83be5b9478b.png)
+ **容器可用空间**
  + 系统严格按代码的**前后组织**顺序依次排列组件，前辈组件还没有占据的空间，是当前组件的可用空间，pack布局是在当前组件的可用空间内进行的
+ **组件原始可见空间**
  + 设置了**width**, **height**, 或由具体内容确定的组件原始大小，也就是可以看得见的组件宽高。如上图的**黄色区域**。
+ **组件的独占空间**
  + 组件不单只占据它原始可见的位置，而是会同时占据可用空间的整行空间或整列空间。如上图**红色区域**。
  + **组件独占空间**，没有进行填充(**fill**)时，**不可见**，但我们必须了解到它的存在，因为它直接影响组件本身及**后辈组件的布局**。
  + **组件独占空间**，是固有的，其它后辈组件绝对不可能进入该空间，后辈组件最多只能紧靠它。
+ **组件可扩展空间**
  + 组件可扩展空间，没有进行填充(**fill**)时，也是**不可见**的，但它同样会直接影响自身和后辈组件的布局，必须掌握它的空间存在。
  + 若设置了 **expand** = yes, 则**启用可扩展空间**；若 expand = no, 则**不启用可扩展空间。**
  + 组件**可扩展空间**，是**动态**的，是可以**被后辈组件的独占空间占据压缩的**，后辈组件可以从前辈可扩展空间的边缘开始入侵，直至压缩到前辈组件自身的独占空间为止。
+ **组件占用总空间**
  + 组件独占空间 + 组件可扩展空间，就是当前组件的总占用空间，若没有启用组件扩展空间（**expand** = no），则只包含**组件独占空间**。
  + 接下来的 锚定位(**anchor**)和填充(**fill**)，都是基于**组件的占用总空间**来进行处理的。
+ **空间定位和填充**
  + **锚定位（anchor ），加 padx, pady , 可将组件安排在指定位置**
  + 锚定位有**9**个方向，缺省为 **center**, **居中**
  + 若 side = **top / bottom** ,  **expand=no**, 则合并到**一行**，即**NW, W, SW**的效果一样，其他同理。
  + 若 side = **left / right**,  **expand = no**, 则合并到**一列**，即**NW, N, NE**的效果一样，其他同理
  + ![](https://pic.downk.cc/item/5ec8dcb5c2a9a83be5ba6cdc.png)
+ **空间优先级**
  + 界面空间 > 前辈组件独占空间 > 后辈组件独占空间 > 前辈组件可扩展空间 > 后辈组件可扩展空间
+ 可以利用**frame**的多层嵌套进行灵活布局